\section{Módulo de Optimización de Tiempos Semafóricos}
\label{sec:algoritmos_traffic_sync}

El módulo \texttt{traffic-sync} implementa el servicio de optimización de tráfico del sistema, exponiendo una API que recibe mediciones macroscópicas de tráfico por semáforo y devuelve configuraciones de tiempos optimizadas. Para ello combina dos componentes principales: un sistema de inferencia difusa tipo Mamdani, que evalúa el nivel de congestión a partir de variables de flujo, velocidad y densidad; y un algoritmo de optimización Particle Swarm Optimization (PSO), que ajusta dinámicamente los tiempos de verde con el objetivo de reducir la congestión estimada \cite{mamdani1975experiment,zadeh1965fuzzy,kennedy1995particle}.

% -----------------------------------------------------------------------------
\subsection{Lógica Difusa Mamdani}
\label{subsec:fuzzy_traffic_sync}

La lógica difusa proporciona un marco formal para representar razonamiento humano impreciso mediante variables lingüísticas y conjuntos difusos con grados de pertenencia entre 0 y 1 \cite{zadeh1965fuzzy,zadeh1971similarity}. En un sistema de inferencia Mamdani, las reglas tienen la forma ``SI condición ENTONCES acción'', donde tanto antecedentes como consecuentes se modelan como conjuntos difusos, y la salida final se obtiene tras un proceso de agregación y defuzzificación \cite{mamdani1975experiment,ross2010fuzzy}. Este enfoque resulta especialmente adecuado para describir estados de tráfico como ``flujo libre'', ``denso'' o ``congestionado'' a partir de variables macroscópicas continuas \cite{erdinc2023application,musriroh2020application}.

En \texttt{traffic-sync}, el sistema de inferencia difusa se implementa en el paquete \texttt{modules.fuzzy}, que está compuesto principalmente por los módulos \texttt{system.py} y \texttt{evaluation.py}. El módulo \texttt{system.py} define las variables lingüísticas de entrada (por ejemplo, vehículos por minuto, velocidad media, tiempo medio de circulación, densidad) y la variable de salida asociada al nivel de congestión, junto con sus funciones de membresía triangulares y trapezoidales calibradas en base a datos de tráfico y criterios de ingeniería \cite{ross2010fuzzy,erdinc2023application}. La base de reglas Mamdani captura relaciones cualitativas del tipo ``SI flujo es alto Y velocidad es baja ENTONCES congestión es severa'', que reflejan tanto conocimiento experto como patrones observados en los datos \cite{musriroh2020application}.

El módulo \texttt{evaluation.py} expone funciones de alto nivel, como \texttt{run\_test\_cases}, que reciben vectores de métricas de tráfico en formato dict y devuelven, para cada sensor o semáforo, un valor numérico de congestión y su categoría lingüística asociada. Estas funciones se utilizan en el pipeline principal definido en \texttt{api/server.py}: el endpoint \texttt{/evaluate} recibe un lote de sensores, construye las entradas para el sistema difuso, ejecuta la evaluación Mamdani sobre cada uno y genera un conjunto de salidas que se utilizarán como insumo para la etapa de optimización PSO. De esta forma, la lógica difusa actúa como módulo de evaluación de desempeño que transforma mediciones de tráfico en un índice de congestión interpretable, que el optimizador buscará reducir.

% -----------------------------------------------------------------------------
\subsection{Optimización de Enjambre de Partículas (PSO)}
\label{subsec:pso_traffic_sync}

Optimización de Enjambre de Partículas (PSO) es un algoritmo de optimización metaheurística inspirado en el comportamiento colectivo de bandadas de aves y bancos de peces, en el que un conjunto de partículas explora el espacio de búsqueda guiado por su mejor experiencia individual y la mejor experiencia global del grupo \cite{kennedy1995particle,eberhart1995new}. Cada partícula representa una solución candidata (en este caso, una posible asignación de tiempo de verde para un grupo de semáforos) y actualiza su posición combinando tres componentes: inercia, atracción hacia su mejor posición personal y atracción hacia la mejor posición global conocida, ponderadas por parámetros que controlan el equilibrio entre exploración y explotación \cite{clerc2002particle,shi1998parameter}.

En el módulo \texttt{traffic-sync}, la lógica de PSO se implementa en el paquete \texttt{modules.pso}, que incluye \texttt{fitness.py} y \texttt{optimization.py}. El archivo \texttt{optimization.py} define la función \texttt{pso}, que recibe un \texttt{DataFrame} de \texttt{pandas} con información agregada de tráfico por grupo (cluster) y aplica PSO para determinar el tiempo de verde óptimo por grupo. Cada partícula codifica un tiempo de verde propuesto para el ciclo semafórico, inicializado alrededor de un valor base calculado mediante fórmulas clásicas de ingeniería de tráfico (función \texttt{calculate\_green\_time} en \texttt{fitness.py}), y restringido por límites mínimos y máximos coherentes con la normativa \cite{webster1958traffic,garber2019traffic}. El algoritmo utiliza configuraciones típicas de PSO (número de partículas, peso de inercia, componentes cognitiva y social, límites de velocidad) y añade mecanismos prácticos como parada temprana y reinicios parciales para evitar estancamiento en óptimos locales pobres.

La función de aptitud (\texttt{fitness\_function}, definida en \texttt{fitness.py}) evalúa cada propuesta de tiempo de verde combinando la lógica difusa y las métricas de tráfico: dado un tiempo de verde candidato, recalcula métricas derivadas (como volumen efectivo, velocidad y densidad ajustadas) y vuelve a evaluar el nivel de congestión mediante el sistema Mamdani, obteniendo un valor numérico que se utiliza como medida a minimizar \cite{papageorgiou2003review,stevanovic2010adaptive}. De este modo, PSO busca explícitamente reducir el índice de congestión proporcionado por el módulo difuso, en lugar de optimizar una función analítica cerrada.

En el pipeline de \texttt{traffic-sync}, orquestado por la función \texttt{run\_pipeline} en \texttt{api/server.py}, el flujo es el siguiente: (i) el servicio recibe un lote de sensores en la API \texttt{/evaluate}; (ii) las mediciones se pasan al módulo difuso para obtener un nivel de congestión por sensor; (iii) se agrupan sensores con características similares (agrupamiento jerárquico), produciendo un conjunto de grupos de tráfico; (iv) se construye un \texttt{DataFrame} por grupo con métricas agregadas (por ejemplo, vehículos por minuto, velocidad media, densidad media, categoría de congestión); y (v) se aplica la función \texttt{pso} sobre estos grupos para obtener tiempos de verde optimizados por grupo. La respuesta de la API se construye como un lote de optimizaciones, donde cada entrada incluye el tiempo de verde recomendado, el tiempo de rojo derivado, el nivel de congestión original y optimizado, y las categorías lingüísticas correspondientes, preparados para su consumo posterior por el módulo de control de semáforos y por el módulo \texttt{traffic-storage}.

En conjunto, la integración entre lógica difusa Mamdani y PSO en \texttt{traffic-sync} permite que la optimización de tiempos semafóricos se base en una medida de congestión que captura adecuadamente la percepción y el comportamiento del tráfico urbano, mientras que el metaheurístico proporciona un mecanismo flexible para ajustar los parámetros de control en escenarios donde la función objetivo no es derivable y debe evaluarse a través de simulación o reglas de inferencia \cite{ross2010fuzzy,poli2007particle}.
